using QSP.RouteFinding.Airports;
using QSP.RouteFinding.AirwayStructure;
using QSP.RouteFinding.Containers;
using QSP.RouteFinding.RouteAnalyzers.Extractors;
using QSP.RouteFinding.Routes;
using QSP.RouteFinding.TerminalProcedures.Sid;
using QSP.RouteFinding.TerminalProcedures.Star;
using System.Collections.Generic;
using System.Linq;
using static QSP.RouteFinding.Tracks.Common.Utilities;

namespace QSP.RouteFinding.RouteAnalyzers
{
    // Uses BasicRouteAnalyzer, with the additional functionality of 
    // reading airports and SIDs/STARs.
    //
    // 1. Input: The string array, consisting of airport icao code (ICAO),
    //    airway (AWY), and waypoint (WPT) sysbols.
    //           
    // 2. All characters should be capital.
    //
    // 3. Format: {ICAO, SID, WPT, AWY, WPT, ... , WPT, STAR, ICAO}
    //    (1) First ICAO must be identical to origin icao code. Last 
    //        ICAO must be identical to dest icao code.
    //    (2) Both ICAO can be omitted.
    //    (3) If an airway is DCT (direct), it have to be omitted. The 
    //        route will be a direct between the two waypoints.
    //    (4) SID/STAR can be omitted. The route will be a direct from/to 
    //        airport.
    //    (5) All WPT, except for the last waypoint of the SID or first 
    //        one of the STAR, must exist in wptList.
    //             
    // 4. All cases of SID/STAR, specified in SidAdder/StarAdder are 
    //    supported. 
    //    (1) Suppose the last waypoint of SID1 is P1, and P2 is a 
    //        waypoint in wptList. 
    //
    //        "SID1 P1 P2 ..." is equivalent to "SID1 P2 ...". STAR is 
    //        simlilar.  
    //        (The reason for this rule is that the route string 
    //        generated by our RouteFinder can be parsed correctly.)
    //
    // 5. If the format is wrong, an InvalidIdentifierException will be
    //    thrown with an message describing the place where the 
    //    problem occurs.
    //
    // 6. It's not allowed to direct from one waypoint to another which 
    //    is more than 500 nm away. Otherwise an WaypointTooFarException
    //    will be thrown.
    //

    public class StandardRouteAnalyzer
    {
        private WaypointList wptList;
        private AirportManager airportList;
        private SidCollection sids;
        private StarCollection stars;

        private string origIcao;
        private string origRwy;
        private string destIcao;
        private string destRwy;
        private LinkedList<string> route;

        private Waypoint origRwyWpt;
        private Waypoint destRwyWpt;

        public StandardRouteAnalyzer(
            string[] route,
            string origIcao,
            string origRwy,
            string destIcao,
            string destRwy,
            AirportManager airportList,
            WaypointList wptList,
            SidCollection sids,
            StarCollection stars)
        {
            this.route = new LinkedList<string>(route);
            this.origIcao = origIcao;
            this.origRwy = origRwy;
            this.destIcao = destIcao;
            this.destRwy = destRwy;
            this.airportList = airportList;
            this.wptList = wptList;
            this.sids = sids;
            this.stars = stars;
        }

        private void setRwyWpts()
        {
            origRwyWpt = new Waypoint(
                    origIcao + origRwy,
                    airportList.RwyLatLon(origIcao, origRwy));

            destRwyWpt = new Waypoint(
                    destIcao + destRwy,
                    airportList.RwyLatLon(destIcao, destRwy));
        }

        public Route Analyze()
        {
            setRwyWpts();

            Route origPart =
                new SidExtractor(
                    route, origIcao, origRwy, origRwyWpt, wptList, sids)
                    .Extract();

            Route destPart =
                new StarExtractor(
                    route, destIcao, destRwy, destRwyWpt, wptList, stars)
                    .Extract();

            var mainRoute = route.ToArray();

            if (mainRoute.Length == 0)
            {
                origPart.AppendRoute(destPart, "DCT");
            }
            else
            {
                int chosenIndex = GetClosest(
                    origRwyWpt.Lat,
                    origRwyWpt.Lon,
                    wptList.FindAllByID(mainRoute[0]),
                    wptList);

                if (mainRoute.Length == 1)
                {
                    origPart.AddLastWaypoint(wptList[chosenIndex], "DCT");
                    origPart.AppendRoute(destPart, "DCT");
                }
                else
                {
                    var mainPart = new BasicRouteAnalyzer(
                        mainRoute, wptList, chosenIndex).Analyze();

                    origPart.MergeWith(mainPart);
                    origPart.MergeWith(destPart);
                }
            }

            return origPart;
        }
    }
}
