using QSP.RouteFinding.Airports;
using QSP.RouteFinding.AirwayStructure;
using QSP.RouteFinding.Containers;
using QSP.RouteFinding.Data.Interfaces;
using QSP.RouteFinding.RandomRoutes;
using QSP.RouteFinding.RouteAnalyzers.Extractors;
using QSP.RouteFinding.Routes;
using QSP.RouteFinding.TerminalProcedures.Sid;
using QSP.RouteFinding.TerminalProcedures.Star;
using System;
using System.Collections.Generic;
using System.Linq;
using RouteString = System.Collections.Generic.List<string>;

namespace QSP.RouteFinding.RouteAnalyzers
{
    // Uses BasicRouteAnalyzer, with the additional functionality of 
    // reading airports and SIDs/STARs.
    //
    // 1. Input: The string array, consisting of airport icao code (ICAO),
    //    airway (AWY), waypoint (WPT), "AUTO" and "RAND" sysbols.
    //           
    // 2. All characters should be capital.
    //
    // 3. Format: {ICAO, SID, WPT, AWY, WPT, ... , WPT, STAR, ICAO}
    //    (1) First ICAO must be identical to origin icao code. Last 
    //        ICAO must be identical to dest icao code.
    //    (2) Both ICAO can be omitted.
    //    (3) If an airway is DCT (direct), it has to be omitted. The 
    //        route will be a direct between the two waypoints.
    //    (4) SID/STAR can be omitted. The route will be a direct from/to 
    //        airport.
    //    (5) All WPT, except for the last waypoint of the SID or first 
    //        one of the STAR, must exist in wptList.
    //    (6) "AUTO" or "RAND" can only appear before or after ICAO, or 
    //        between two waypoints.
    //    (7) If the route is empty, a direct route from origin to 
    //        destination runway is returned.
    //             
    // 4. All cases of SID/STAR, specified in SidAdder/StarAdder are 
    //    supported. 
    //    (1) Suppose SID1 ends with a vector to a waypoint P, where P is 
    //        in wptList. "SID1 P ..." is valid.

    //        (The reason for this rule is that the route string 
    //        generated by our RouteFinder can be parsed correctly.)
    //
    // 5. If the format is wrong, an InvalidIdentifierException will be
    //    thrown with an message describing the place where the 
    //    problem occurs.
    //
    // 6. "AUTO" finds the shortest route between the specified waypoints.
    //     If it's the first entry, then a route between departure runway 
    //     and first waypoint is found. The case for last entry is similar.
    //     Similarly, "RAND" finds a random route.
    //
    public class AnalyzerWithCommands
    {
        // TODO: What if some coordinate formats are not found in wptList
        // but are valid?
        private WaypointList wptList;
        private AirportManager airportList;
        private SidCollection sids;
        private StarCollection stars;

        private string origIcao;
        private string origRwy;
        private string destIcao;
        private string destRwy;
        private string[] route;

        private Waypoint origRwyWpt;
        private Waypoint destRwyWpt;

        public AnalyzerWithCommands(
            string[] route,
            string origIcao,
            string origRwy,
            string destIcao,
            string destRwy,
            AirportManager airportList,
            WaypointList wptList,
            SidCollection sids,
            StarCollection stars)
        {
            this.route = route;
            this.origIcao = origIcao;
            this.origRwy = origRwy;
            this.destIcao = destIcao;
            this.destRwy = destRwy;
            this.airportList = airportList;
            this.wptList = wptList;
            this.sids = sids;
            this.stars = stars;
        }

        public Route Analyze()
        {
            SetRwyWpts();
            if (route.Length == 0) return DirectRoute();

            EnsureNoConsectiveCommands(route);
            route = RemoveIcaos(route);

            var subRoutes = GroupEntries(route);
            var analyzed = ComputeRoutes(subRoutes);
            FillCommands(subRoutes, analyzed);
            return ConnectAll(analyzed);
        }

        private Route DirectRoute()
        {
            var route = new Route();
            route.AddLastWaypoint(origRwyWpt);
            route.AddLastWaypoint(destRwyWpt, "DCT");
            return route;
        }

        private string[] RemoveIcaos(string[] route)
        {
            bool firstIsIcao = route[0] == origIcao;
            bool lastIsIcao = route.Last() == destIcao;

            int skipHead = firstIsIcao ? 1 : 0;
            int skipTail = lastIsIcao ? 1 : 0;

            return route
                .Skip(skipHead)
                .Take(route.Length - skipHead - skipTail)
                .ToArray();
        }

        private static void EnsureNoConsectiveCommands(string[] route)
        {
            string[] commands = { "AUTO", "RAND" };
            for (int i = 0; i < route.Length - 1; i++)
            {
                var first = route[i];
                var second = route[i + 1];

                if (commands.Contains(first) && commands.Contains(second))
                {
                    throw new ArgumentException(
                        $"{first} cannot be followed by {second}");
                }
            }
        }

        // Group the route into several parts to seperate "AUTO" and "RAND"
        // from actual route.
        // For example, 'A B AUTO C D RAND E' is grouped into:
        // 'A B'
        // 'AUTO'
        // 'C D'
        // 'RAND'
        // 'E'
        private static List<RouteString> GroupEntries(string[] route)
        {
            var subRoutes = new List<RouteString>();
            var current = new RouteString();

            foreach (var i in route)
            {
                if (i == "AUTO" || i == "RAND")
                {
                    if (current.Count > 0)
                    {
                        subRoutes.Add(current);
                        current = new RouteString();
                    }

                    subRoutes.Add(new RouteString { i });
                }
                else
                {
                    current.Add(i);
                }
            }

            if (current.Count > 0) subRoutes.Add(current);

            return subRoutes;
        }

        private void SetRwyWpts()
        {
            origRwyWpt = new Waypoint(
                origIcao + origRwy,
                airportList.FindRwy(origIcao, origRwy));

            destRwyWpt = new Waypoint(
                destIcao + destRwy,
                airportList.FindRwy(destIcao, destRwy));
        }

        // Transform each RouteString to Route.
        private List<Route> ComputeRoutes(List<RouteString> subRoutes)
        {
            var result = new List<Route>();

            for (int i = 0; i < subRoutes.Count; i++)
            {
                var route = subRoutes[i];

                if (route.Count == 1 &&
                    (route[0] == "AUTO" || route[0] == "RAND"))
                {
                    result.Add(null);
                }
                else if (i == 0)
                {
                    result.Add(ComputeOriginRoute(route));
                }
                else if(i == subRoutes.Count - 1)
                {
                    // TODO: This does not work when i == 0. 
                    result.Add(ComputeDestRoute(route));
                }
                else
                {
                    var mainRoute = new AutoSelectAnalyzer(
                        route.ToArray(),
                        origRwyWpt,
                        destRwyWpt,
                        wptList).Analyze();

                    result.Add(mainRoute);
                }
            }

            return result;
        }

        private Route ComputeOriginRoute(RouteString item)
        {
            var sidExtract = new SidExtractor(item, origIcao,
                origRwy, origRwyWpt, wptList, sids).Extract();

            var origRoute = sidExtract.OrigRoute;

            var mainRoute = new AutoSelectAnalyzer(
                sidExtract.RemainingRoute.ToArray(),
                origRwyWpt,
                destRwyWpt,
                wptList).Analyze();

            origRoute.Connect(mainRoute);
            return origRoute;
        }

        private Route ComputeDestRoute(RouteString item)
        {
            var starExtract = new StarExtractor(item, destIcao,
                destRwy, destRwyWpt, wptList, stars).Extract();

            var destRoute = starExtract.DestRoute;

            var mainRoute = new AutoSelectAnalyzer(
                starExtract.RemainingRoute.ToArray(),
                origRwyWpt,
                destRwyWpt,
                wptList).Analyze();

            mainRoute.Connect(destRoute);
            return mainRoute;
        }
        
        private void FillCommands(
            List<RouteString> subRoutes, List<Route> analyzed)
        {
            for (int i = 0; i < subRoutes.Count; i++)
            {
                if (analyzed[i] == null)
                {
                    var startEnd = GetStartEndWpts(analyzed, i);

                    if (subRoutes[i][0] == "AUTO")
                    {
                        analyzed[i] = FindRoute(analyzed, i);
                    }
                    else
                    {
                        // RAND
                        var randRoute = FinderFactory.GetInstance()
                            .Find(startEnd.Start, startEnd.End)
                            .ToRoute();
                        
                        randRoute.Nodes.RemoveFirst();
                        randRoute.Nodes.RemoveLast();
                        randRoute.AddFirstWaypoint(startEnd.Start, "DCT");
                        randRoute.AddLastWaypoint(startEnd.End, "DCT");
                        
                        analyzed[i] = randRoute;
                    }
                }
            }
        }

        private Route FindRoute(List<Route> analyzed, int index)
        {
            var routeFinder = new RouteFinder(wptList);

            if (index == 0)
            {
                if (index == analyzed.Count - 1)
                {
                    return new RouteFinderFacade(wptList, airportList)
                        .FindRoute(
                        origIcao, origRwy, sids, sids.GetSidList(origRwy),
                        destIcao, destRwy, stars, stars.GetStarList(destRwy));
                }
                else
                {
                    int wptTo = wptList.FindByWaypoint(
                        analyzed[index + 1].FirstWaypoint);

                    return new RouteFinderFacade(wptList, airportList)
                        .FindRoute(origIcao, origRwy, sids,
                            sids.GetSidList(origRwy), wptTo);
                }
            }
            else
            {
                if (index == analyzed.Count - 1)
                {
                    int wptFrom = wptList.FindByWaypoint(
                        analyzed[index - 1].LastWaypoint);

                    return new RouteFinderFacade(wptList, airportList)
                         .FindRoute(wptFrom, destIcao, destRwy, stars,
                         stars.GetStarList(destRwy));
                }
                else
                {
                    int wptFrom = wptList.FindByWaypoint(
                        analyzed[index - 1].LastWaypoint);

                    int wptTo = wptList.FindByWaypoint(
                        analyzed[index + 1].FirstWaypoint);

                    return routeFinder.FindRoute(wptFrom, wptTo);
                }
            }
        }
        
        private WptPair GetStartEndWpts(List<Route> subRoutes, int index)
        {
            var start = index == 0
                ? origRwyWpt
                : subRoutes[index - 1].LastWaypoint;

            var end = index == subRoutes.Count - 1
                ? destRwyWpt
                : subRoutes[index + 1].FirstWaypoint;

            return new WptPair() { Start = start, End = end };
        }

        private static Route ConnectAll(List<Route> subRoutes)
        {
            var route = subRoutes[0];

            for (int i = 1; i < subRoutes.Count; i++)
            {
                route.Connect(subRoutes[i]);
            }

            return route;
        }

        private struct WptPair { public Waypoint Start, End; }
    }
}
