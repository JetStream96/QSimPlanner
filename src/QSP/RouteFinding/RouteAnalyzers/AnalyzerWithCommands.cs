using QSP.RouteFinding.Airports;
using QSP.RouteFinding.AirwayStructure;
using QSP.RouteFinding.Containers;
using QSP.RouteFinding.RouteAnalyzers.Extractors;
using QSP.RouteFinding.Routes;
using QSP.RouteFinding.TerminalProcedures.Sid;
using QSP.RouteFinding.TerminalProcedures.Star;
using System;
using System.Collections.Generic;
using System.Linq;
using QSP.RouteFinding.RandomRoutes;
using QSP.RouteFinding.Data.Interfaces;
using RouteString = System.Collections.Generic.List<string>;

namespace QSP.RouteFinding.RouteAnalyzers
{
    // Uses BasicRouteAnalyzer, with the additional functionality of 
    // reading airports and SIDs/STARs.
    //
    // 1. Input: The string array, consisting of airport icao code (ICAO),
    //    airway (AWY), waypoint (WPT), "AUTO" and "RAND" sysbols.
    //           
    // 2. All characters should be capital.
    //
    // 3. Format: {ICAO, SID, WPT, AWY, WPT, ... , WPT, STAR, ICAO}
    //    (1) First ICAO must be identical to origin icao code. Last 
    //        ICAO must be identical to dest icao code.
    //    (2) Both ICAO can be omitted.
    //    (3) If an airway is DCT (direct), it have to be omitted. The 
    //        route will be a direct between the two waypoints.
    //    (4) SID/STAR can be omitted. The route will be a direct from/to 
    //        airport.
    //    (5) All WPT, except for the last waypoint of the SID or first 
    //        one of the STAR, must exist in wptList.
    //    (6) "AUTO" or "RAND" can only appear before or after ICAO, or 
    //        between two waypoints.
    //             
    // 4. All cases of SID/STAR, specified in SidAdder/StarAdder are 
    //    supported. 
    //    (1) Suppose the last waypoint of SID1 is P1, and P2 is a 
    //        waypoint in wptList. 
    //
    //        "SID1 P1 P2 ..." is equivalent to "SID1 P2 ...". STAR is 
    //        simlilar.  
    //        (The reason for this rule is that the route string 
    //        generated by our RouteFinder can be parsed correctly.)
    //
    // 5. If the format is wrong, an InvalidIdentifierException will be
    //    thrown with an message describing the place where the 
    //    problem occurs.
    //
    // 6. "AUTO" finds the shortest route between the specified waypoints.
    //     If it's the first entry, then a route between departure runway 
    //     and first waypoint is found. The case for last entry is similar.
    //     Similarly, "RAND" finds a random route.
    //
    public class AnalyzerWithCommands
    {
        private WaypointList wptList;
        private AirportManager airportList;
        private SidCollection sids;
        private StarCollection stars;

        private string origIcao;
        private string origRwy;
        private string destIcao;
        private string destRwy;
        private string[] route;

        private Waypoint origRwyWpt;
        private Waypoint destRwyWpt;

        public AnalyzerWithCommands(
            string[] route,
            string origIcao,
            string origRwy,
            string destIcao,
            string destRwy,
            AirportManager airportList,
            WaypointList wptList,
            SidCollection sids,
            StarCollection stars)
        {
            if (route.Length == 0)
            {
                throw new ArgumentException(
                    "Route input should have at least 1 elements.");
            }

            this.route = route;
            this.origIcao = origIcao;
            this.origRwy = origRwy;
            this.destIcao = destIcao;
            this.destRwy = destRwy;
            this.airportList = airportList;
            this.wptList = wptList;
            this.sids = sids;
            this.stars = stars;
        }

        public Route Analyze()
        {
            SetRwyWpts();
            var subRoutes = GroupEntries(route);
            var analyzed = ComputeRoutes(subRoutes);
            FillCommands(subRoutes, analyzed);
            return ConnectAll(analyzed);
        }

        // Group the route into several parts to seperate "AUTO" and "RAND"
        // from actual route.
        // For example, 'A B AUTO C D RAND E' is grouped into:
        // 'A B'
        // 'AUTO'
        // 'C D'
        // 'RAND'
        // 'E'
        private static List<RouteString> GroupEntries(string[] route)
        {
            var subRoutes = new List<RouteString>();
            var current = new RouteString();

            foreach (var i in route)
            {
                if (i == "AUTO" || i == "RAND")
                {
                    if (current.Count > 0)
                    {
                        subRoutes.Add(current);
                        current = new RouteString();
                    }

                    subRoutes.Add(new RouteString { i });
                }
                else
                {
                    current.Add(i);
                }
            }

            if (current.Count > 0) subRoutes.Add(current);

            return subRoutes;
        }

        private void SetRwyWpts()
        {
            origRwyWpt = new Waypoint(
                origIcao + origRwy,
                airportList.RwyLatLon(origIcao, origRwy));

            destRwyWpt = new Waypoint(
                destIcao + destRwy,
                airportList.RwyLatLon(destIcao, destRwy));
        }

        private List<Route> ComputeRoutes(List<RouteString> subRoutes)
        {
            var result = new List<Route>();

            for (int i = 0; i < subRoutes.Count; i++)
            {
                IEnumerable<string> route = subRoutes[i];

                if (route.Count() == 1 &&
                    (route.First() == "AUTO" ||
                     route.First() == "RAND"))
                {
                    result.Add(null);
                }
                else
                {
                    Route origRoute = null;
                    Route destRoute = null;
                    bool sidExists = false;

                    if (i == 0)
                    {
                        var sidExtract = new SidExtractor(route, origIcao,
                            origRwy, origRwyWpt, wptList, sids).Extract();

                        origRoute = sidExtract.Sid;
                        route = sidExtract.RemainingRoute;
                        sidExists = sidExtract.SidExists;
                    }

                    if (i == subRoutes.Count - 1)
                    {
                        var starExtract = new StarExtractor(route, destIcao,
                            destRwy, destRwyWpt, wptList, stars).Extract();

                        destRoute = starExtract.Star;
                        route = starExtract.RemainingRoute;
                    }

                    var mainRoute = new AutoSelectAnalyzer(
                        route.ToArray(),
                        origRwyWpt.Lat,
                        origRwyWpt.Lon,
                        wptList).Analyze();

                    result.Add(AppendRoute(
                        origRoute,
                        AppendRoute(mainRoute, destRoute),
                        sidExists));
                }
            }

            return result;
        }

        private static Route AppendRoute(
            Route original, Route routeToAppend, bool useLastAirway = false)
        {
            if (original == null)
            {
                return routeToAppend;
            }

            if (routeToAppend == null)
            {
                return original;
            }

            original.Merge(routeToAppend, useLastAirway);
            return original;
        }

        private void FillCommands(
            List<RouteString> subRoutes, List<Route> analyzed)
        {
            for (int i = 0; i < subRoutes.Count; i++)
            {
                if (analyzed[i] == null)
                {
                    var startEnd = GetStartEndWpts(analyzed, i);

                    if (subRoutes[i][0] == "AUTO")
                    {
                        analyzed[i] = FindRoute(analyzed, i);
                    }
                    else
                    {
                        // RAND
                        var randRoute = FinderFactory.GetInstance()
                            .Find(startEnd.Start, startEnd.End)
                            .ToRoute();

                        RandRouteAddOrigDest(randRoute, analyzed, i);
                        analyzed[i] = randRoute;
                    }
                }
            }
        }

        private Route FindRoute(List<Route> analyzed, int index)
        {
            var routeFinder = new RouteFinder(wptList);

            if (index == 0)
            {
                if (index == analyzed.Count - 1)
                {
                    return new RouteFinderFacade(wptList, airportList)
                        .FindRoute(
                        origIcao, origRwy, sids, sids.GetSidList(origRwy),
                        destIcao, destRwy, stars, stars.GetStarList(destRwy));
                }
                else
                {
                    int wptTo = wptList.FindByWaypoint(analyzed[index + 1].FirstWaypoint);

                    return new RouteFinderFacade(wptList, airportList)
                          .FindRoute(origIcao, origRwy, sids, sids.GetSidList(origRwy), wptTo);
                }
            }
            else
            {
                if (index == analyzed.Count - 1)
                {
                    int wptFrom = wptList.FindByWaypoint(analyzed[index - 1].LastWaypoint);

                    return new RouteFinderFacade(wptList, airportList)
                         .FindRoute(wptFrom, destIcao, destRwy, stars, stars.GetStarList(destRwy));
                }
                else
                {
                    int wptFrom = wptList.FindByWaypoint(analyzed[index - 1].LastWaypoint);
                    int wptTo = wptList.FindByWaypoint(analyzed[index + 1].FirstWaypoint);

                    return routeFinder.FindRoute(wptFrom, wptTo);
                }
            }
        }

        private void RandRouteAddOrigDest(Route route, List<Route> analyzed, int index)
        {
            if (index == 0)
            {
                route.Nodes.RemoveFirst();
                route.AddFirstWaypoint(origRwyWpt, "DCT");
            }

            if (index == analyzed.Count - 1)
            {
                route.Nodes.RemoveLast();
                route.AddLastWaypoint(destRwyWpt, "DCT");
            }
        }

        private WptPair GetStartEndWpts(List<Route> subRoutes, int index)
        {
            var start = index == 0
                ? origRwyWpt
                : subRoutes[index - 1].LastWaypoint;

            var end = index == subRoutes.Count - 1
                ? destRwyWpt
                : subRoutes[index + 1].FirstWaypoint;

            return new WptPair() { Start = start, End = end };
        }

        private static Route ConnectAll(List<Route> subRoutes)
        {
            var route = subRoutes[0];

            for (int i = 1; i < subRoutes.Count; i++)
            {
                route.Merge(subRoutes[i]);
            }

            return route;
        }

        private struct WptPair { public Waypoint Start, End; }
    }
}
