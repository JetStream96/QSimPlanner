using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using QSP.AviationTools.Coordinates;
using QSP.RouteFinding.AirwayStructure;
using QSP.RouteFinding.Containers;
using QSP.RouteFinding.Routes;
using QSP.RouteFinding.Airports;
using static QSP.LibraryExtension.Arrays;
using static QSP.LibraryExtension.Lists;
using static QSP.MathTools.Utilities;
using QSP.RouteFinding.TerminalProcedures.Sid;
using QSP.RouteFinding.TerminalProcedures.Star;
using static QSP.RouteFinding.Tracks.Common.Utilities;

namespace QSP.RouteFinding.RouteAnalyzers
{
    // Utilizes BasicRouteAnalyzer, with the additional functionality of reading airports and SIDs/STARs.
    //
    // 1. Input: The string array, consisting of airport icao code (ICAO), airway (AWY), 
    //    and/or waypoint (WPT) sysbols.
    //           
    // 2. All characters should be capital.
    //
    // 3. Format: {ICAO, SID, WPT, AWY, WPT, ... , WPT, STAR, ICAO}
    //    (1) First ICAO must be identical to origin icao code. Last ICAO must be identical to dest icao code.
    //    (2) Both ICAO can be omitted.
    //    (3) If an airway is DCT (direct), it have to be omitted. The route will be a direct between the two waypoints.
    //    (4) SID/STAR can be omitted. The route will be a direct from/to airport.
    //                 
    // 4. All cases of SID/STAR, specified in SidAdder/StarAdder are supported. 
    //    (1) Suppose the last waypoint of SID1 is P1, and P2 is a waypoint in wptList. 
    //        "SID1 P1 P2 ..." is equivalent to "SID1 P2 ...". STAR is simlilar.  
    //        (The reason for this rule is that the route string generated by our RouteFinder can be parsed correctly.)

    // 5. If the format is wrong, an InvalidIdentifierException will be thrown with an message describing 
    //    the place where the problem occurs.
    //
    // 6. It's not allowed to direct from one waypoint to another which is more than 500 nm away.
    //    Otherwise an WaypointTooFarException will be thrown.
    //

    public class StandardRouteAnalyzer
    {
        private WaypointList wptList;
        private AirportManager airportList;
        private SidCollection sids;
        private StarCollection stars;

        private string origIcao;
        private string origRwy;
        private string destIcao;
        private string destRwy;
        private LinkedList<string> route;

        private Route origPart = new Route();
        private Route destPart = new Route();

        Waypoint origRwyWpt;
        Waypoint destRwyWpt;

        public StandardRouteAnalyzer(string[] route,
                                     string origIcao,
                                     string origRwy,
                                     string destIcao,
                                     string destRwy,
                                     AirportManager airportList,
                                     WaypointList wptList,
                                     SidCollection sids,
                                     StarCollection stars)
        {
            this.route = new LinkedList<string>(route);
            this.origIcao = origIcao;
            this.origRwy = origRwy;
            this.destIcao = destIcao;
            this.destRwy = destRwy;
            this.airportList = airportList;
            this.wptList = wptList;
            this.sids = sids;
            this.stars = stars;
        }

        private void setRwyWpts()
        {
            origRwyWpt = new Waypoint(origIcao + origRwy, airportList.RwyLatLon(origIcao, origRwy));
            destRwyWpt = new Waypoint(destIcao + destRwy, airportList.RwyLatLon(destIcao, destRwy));
        }

        public Route Analyze()
        {
            setRwyWpts();
            createOrigRoute();
            createDestRoute();

            var mainRoute = route.ToArray();

            if (mainRoute.Length == 0)
            {
                origPart.AppendRoute(destPart, "DCT");
            }
            else
            {
                int chosenIndex = ChooseSubsequentWpt(origRwyWpt.Lat,
                                                      origRwyWpt.Lon,
                                                      wptList.FindAllByID(mainRoute[0]),
                                                      wptList);

                if (mainRoute.Length == 1)
                {
                    origPart.AddLastWaypoint(wptList[chosenIndex], "DCT", true);
                    origPart.AppendRoute(destPart, "DCT");
                }
                else
                {
                    var mainPart = new BasicRouteAnalyzer(mainRoute, wptList, chosenIndex).Analyze();
                    mergeRoutes(origPart, mainPart);
                    mergeRoutes(origPart, destPart);
                }
            }
            return origPart;
        }

        private bool tryGetSid(string sidName, Waypoint origRwyWpt, out SidInfo result)
        {
            try
            {
                result = sids.GetSidInfo(sidName, origRwy, origRwyWpt);
                return true;
            }
            catch
            {
                // no SID in route
                result = null;
                return false;
            }
        }

        private void createOrigRoute()
        {
            origPart.AddLastWaypoint(origRwyWpt);

            if (route.Count == 0)
            {
                return;
            }

            if (route.First.Value == origIcao)
            {
                route.RemoveFirst();
            }

            string sidName = route.First.Value;
            SidInfo sid;

            if (tryGetSid(sidName, origRwyWpt, out sid))
            {
                route.RemoveFirst();
                origPart.Last.AirwayToNext = sidName;

                if (Math.Abs(sid.TotalDistance) > 1E-8)
                {
                    // SID has at least one waypoint.                    
                    origPart.Last.DistanceToNext = sid.TotalDistance;
                    origPart.AddLastWaypoint(sid.LastWaypoint);

                    if (route.First.Value == sid.LastWaypoint.ID &&
                        wptList.FindAllByWaypoint(sid.LastWaypoint).Count == 0)
                    {
                        route.RemoveFirst();
                    }
                }
            }
        }

        private void mergeRoutes(Route original, Route RouteToMerge)
        {
            if (original.Last.Equals(RouteToMerge.First))
            {
                original.ConnectRoute(RouteToMerge);
            }
            else
            {
                original.AppendRoute(RouteToMerge, "DCT");
            }
        }

        private bool tryGetStar(string StarName, Waypoint destRwyWpt, out StarInfo result)
        {
            try
            {
                result = stars.GetStarInfo(StarName, destRwy, destRwyWpt);
                return true;
            }
            catch
            {
                // no Star in route
                result = null;
                return false;
            }
        }

        private void createDestRoute()
        {
            destPart.AddLastWaypoint(destRwyWpt);

            if (route.Count == 0)
            {
                return;
            }

            if (route.Last.Value == destIcao)
            {
                route.RemoveLast();
            }

            string starName = route.Last.Value;
            StarInfo star;

            if (tryGetStar(starName, destRwyWpt, out star))
            {
                route.RemoveLast();
                // STAR has at least one waypoint.
                destPart.AddFirstWaypoint(star.FirstWaypoint, starName, star.TotalDistance);

                if (route.Last.Value == star.FirstWaypoint.ID &&
                    wptList.FindAllByWaypoint(star.FirstWaypoint).Count == 0)
                {
                    route.RemoveLast();
                }
            }
        }
    }
}
